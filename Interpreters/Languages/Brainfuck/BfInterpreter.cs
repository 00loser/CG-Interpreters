using System;
using System.Text;
using System.Linq;
using Interpreters.Utils;

namespace Interpreters
{
    public class BfInterpreter
    { 
        private const short memSize = 3000; //default memory size
        private readonly byte[] memory = new byte[0];
        private int memPointer = 0;
        private StringBuilder _output = new StringBuilder();
        private string _code = string.Empty;
        private int[] _inputs = new int[0];

        public string Code
        {
            get => _code;
            set => _code = value;
        }

        public int[] Inputs
        {
            get => _inputs;
            set => _inputs = value;
        }

        public string Output
        {
            get => _output.ToString();
        }     

        public BfInterpreter() =>
            memory = new byte[memSize];

        public BfInterpreter(string code)
        {
            _code = code;
            memory = new byte[memSize];
        }

        public BfInterpreter(int memorySize)
        {
            memory = new byte[memorySize];
        }

        public BfInterpreter(string code, int memorySize)
        {
            _code = code;
            memory = new byte[memorySize];
        }

        public BfInterpreter(string code, int[] inputs,  int memorySize)
        {
            _code = code;
            _inputs = inputs;
            memory = new byte[memorySize];
        }

        public static string ToBf(string input)
        {
            byte[] chars = Encoding.ASCII.GetBytes(input);
            StringBuilder output = new StringBuilder();
            for (int i = 0; i < chars.Length; i++)
            {
                for (int j = 0; j < chars[i]; j++)
                    output.Append(Operations.Increment);
                output.Append(Operations.Print);
                if (i != chars.Length - 1)
                    output.Append(Operations.PIncrement);
            }
            return output.ToString(); //code generated by this method doesnt use jumps so it will be larger
        }

        public void Execute()
        {
            int codeSize = _code.Length;
            _code = _code.Sanitize();
            if (string.IsNullOrWhiteSpace(_code) || _code.Count(ch => ch == '[') != _code.Count(ch => ch == ']'))
                throw new InterpreterException(0, _code, "Syntax error");
            var pairs = _code.FindPairs();
            int n = 0; //inputs index
            int index = 0;
            _output = new StringBuilder();
            while (index < _code.Length)
            {
                char op = _code[index];
                if (op == Operations.PIncrement || op == Operations.PDecrement)
                {
                    memPointer = (op == Operations.PIncrement) ? memPointer + 1 : memPointer - 1;
                    if (memPointer > memory.Length - 1 || memPointer < 0)
                        throw new InterpreterException(index, op.ToString(), "Pointer out of bounds");
                }
                else if (op == Operations.Increment || op == Operations.Decrement)
                {
                    if ((op == Operations.Increment && memory[memPointer] + 1 > 255) || (op == Operations.Decrement && memory[memPointer] - 1 < 0))
                        throw new InterpreterException(index, op.ToString(), "Incorrect value");
                    memory[memPointer] = (byte)(op == Operations.Increment ? memory[memPointer] + 1 : memory[memPointer] - 1);
                }
                else if (op == Operations.Print)
                {
                    _output.Append((char)memory[memPointer]);
                }
                else if (op == Operations.Store)
                {
                    if (_inputs.Length < 0)
                        throw new InterpreterException(index, op.ToString(), "No input given");
                    memory[memPointer] = (byte)_inputs[n++];
                }
                else if ((op == Operations.Jump && memory[memPointer] == 0) || (op == Operations.JumpBack && memory[memPointer] != 0))
                {
                    index = op == Operations.Jump ? 
                        pairs[index] + 1 : 
                        pairs.Where(kvp => kvp.Value == index).First().Key + 1;
                    //if (op == Operations.Jump)
                    //    index = pairs[index] + 1;
                    //else
                    //    foreach (var kvp in pairs)
                    //        if (kvp.Value == index)
                    //            index = kvp.Key + 1;
                    continue;
                }
                index++;
            }
            for (int i = 0; i < memory.Length; memory[i] = 0, i++);
            memPointer = 0;
            _inputs = new int[0];
        }
    }
}

